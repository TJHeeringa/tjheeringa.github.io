<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>

  <meta charset="utf-8">
  <meta name="generator" content="quarto-1.3.433">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


  <title></title>
  <style>
    code {
      white-space: pre-wrap;
    }

    span.smallcaps {
      font-variant: small-caps;
    }

    div.columns {
      display: flex;
      gap: min(4vw, 1.5em);
    }

    div.column {
      flex: auto;
      overflow-x: auto;
    }

    div.hanging-indent {
      margin-left: 1.5em;
      text-indent: -1.5em;
    }

    ul.task-list {
      list-style: none;
    }

    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1em;
      /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */
      vertical-align: middle;
    }

    /* CSS for syntax highlighting */
    pre>code.sourceCode {
      white-space: pre;
      position: relative;
    }

    pre>code.sourceCode>span {
      display: inline-block;
      line-height: 1.25;
    }

    pre>code.sourceCode>span:empty {
      height: 1.2em;
    }

    .sourceCode {
      overflow: visible;
    }

    code.sourceCode>span {
      color: inherit;
      text-decoration: inherit;
    }

    div.sourceCode {
      margin: 1em 0;
    }

    pre.sourceCode {
      margin: 0;
    }

    @media screen {
      div.sourceCode {
        overflow: auto;
      }
    }

    @media print {
      pre>code.sourceCode {
        white-space: pre-wrap;
      }

      pre>code.sourceCode>span {
        text-indent: -5em;
        padding-left: 5em;
      }
    }

    pre.numberSource code {
      counter-reset: source-line 0;
    }

    pre.numberSource code>span {
      position: relative;
      left: -4em;
      counter-increment: source-line;
    }

    pre.numberSource code>span>a:first-child::before {
      content: counter(source-line);
      position: relative;
      left: -1em;
      text-align: right;
      vertical-align: baseline;
      border: none;
      display: inline-block;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      padding: 0 4px;
      width: 4em;
    }

    pre.numberSource {
      margin-left: 3em;
      padding-left: 4px;
    }

    div.sourceCode {}

    @media screen {
      pre>code.sourceCode>span>a:first-child::before {
        text-decoration: underline;
      }
    }
  </style>

  
  <link type="text/css" href="/static/blog/shared.css" rel="stylesheet" />
  <link type="text/css" href="/static/blog/nav.css" rel="stylesheet" />

  <script type="text/javascript" src="/static/blog/notebooks/clipboard/clipboard.min.js"></script>
  <script type="text/javascript" src="/static/blog/notebooks/quarto-html/quarto.js"></script>
  <script type="text/javascript" src="/static/blog/notebooks/quarto-html/popper.min.js"></script>
  <script type="text/javascript" src="/static/blog/notebooks/quarto-html/tippy.umd.min.js"></script>
  <script type="text/javascript" src="/static/blog/notebooks/quarto-html/anchor.min.js"></script>

  <link href="/static/blog/notebooks/quarto-html/tippy.css" rel="stylesheet">
  <link href="/static/blog/notebooks/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
  <script type="text/javascript" src="/static/blog/notebooks/bootstrap/bootstrap.min.js"></script>
  <link href="/static/blog/notebooks/bootstrap/bootstrap-icons.css" rel="stylesheet">
  <link href="/static/blog/notebooks/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@100;200;300;400;500;600;700;800;900&amp;display=swap" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"
    integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg=="
    crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"
    integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg=="
    crossorigin="anonymous"></script>
  <script type="application/javascript">define('jquery', [], function () { return window.jQuery; })</script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <script type="text/javascript">
    window.PlotlyConfig = { MathJaxConfig: 'local' };
    if (window.MathJax && window.MathJax.Hub && window.MathJax.Hub.Config) { window.MathJax.Hub.Config({ SVG: { font: "STIX-Web" } }); }
    if (typeof require !== 'undefined') {
      require.undef("plotly");
      requirejs.config({
        paths: {
          'plotly': ['https://cdn.plot.ly/plotly-2.24.1.min']
        }
      });
      require(['plotly'], function (Plotly) {
        window._Plotly = Plotly;
      });
    }
  </script>



</head>

<body class="">
  <nav class="navbar navbar-expand-lg navbar-light bg-white py-3">
    <div class="container px-5 w-100">
        <a class="navbar-brand" href="/"><span class="fw-bolder text-title">Tjeerd Jan Heeringa</span></a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav ms-auto mb-2 mb-lg-0 small fw-bolder">
                <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
                <li class="nav-item"><a class="nav-link" href="/posts">Blog</a></li>
                <li class="nav-item"><a class="nav-link" href="/talks">Talks</a></li>
                <li class="nav-item"><a class="nav-link" href="/papers">Papers</a></li>
                <li class="nav-item"><a class="nav-link" href="/posters">Posters</a></li>
                <li class="nav-item"><a class="nav-link" href="/collaborators">Collaborators</a></li>
            </ul>
        </div>
    </div>
</nav>
  
    <div class="page-columns page-rows-contents page-layout-article" id="quarto-content">
<main class="content" id="quarto-document-content">
<header class="quarto-title-block default" id="title-block-header">
<div class="quarto-title">
<h1 class="title">Burger’s equation</h1>
</div>
<div class="quarto-title-meta">
<div>
<div class="quarto-title-meta-heading">Published</div>
<div class="quarto-title-meta-contents">
<p class="date">January 12, 2024</p>
</div>
</div>
</div>
<div>
<div class="abstract">
<div class="block-title">Abstract</div>
<p>The Burger’s equation is a well-known equation, partly due to it’s shock forming behavior. In this post, we take a closer look at this equation.</p>
</div>
</div>
</header>
<section class="level2" id="introduction">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Burger’s equation (or perhaps more accurately the Hopf equation) is given by <span id="eq-burger"><span class="math display">\[
  u_t(x,t) + u(x,t)u_x(x,t) = 0, \quad u(0)=u_0
\tag{1}\]</span></span> when we consider the circle <span class="math inline">\(S^1\)</span> as domain. The equation is well-known for creating shocks. In this document, we will discuss some aspects of the equation.</p>
<p>For brevity, we write <span class="math inline">\(u\)</span> instead of <span class="math inline">\(u(x,t)\)</span> when it is clear what parts should be fed the <span class="math inline">\((x,t)\)</span> part.</p>
</section>
<section class="level2" id="shocks">
<h2 class="anchored" data-anchor-id="shocks">Shocks</h2>
<p>We mentioned that the inviscid Burger’s equation is well-known for creating shocks. In this section we show that it indeed exhibits shocks. We will first do this by direct simulation and then use a more theoretical approach in which we prove the shock.</p>
<section class="level3" id="solving-using-the-method-of-characteristics">
<h3 class="anchored" data-anchor-id="solving-using-the-method-of-characteristics">Solving using the method of characteristics</h3>
<p>The characteristics equations of the method are <span class="math display">\[\begin{align}
  \frac{dx}{ds} &amp;= u \\
  \frac{dt}{ds} &amp;= 1 \\
  \frac{du}{ds} &amp;= 0
\end{align}\]</span> The second shows that <span class="math inline">\(t=s\)</span>, the third shows that <span class="math inline">\(u=c\)</span> for some constant <span class="math inline">\(c\)</span>, and the first shows that <span class="math inline">\(x(s)=us+b\)</span> for some <span class="math inline">\(b\)</span>. <span class="math inline">\(u\)</span> being constant but also starting as <span class="math inline">\(f\)</span> means that it satisfies <span class="math display">\[
  u(x(t),t) = c = u(x(0),0) = f(x(0)) = f(b).
\]</span> Substituting this back into <span class="math inline">\(x\)</span> gives <span class="math display">\[
  x(t) = u t + b = f(b)t+b.
\]</span> This means that the solutions can be expressed as the parametric equations <span class="math display">\[\begin{align}
  u(x,t) &amp;= f(b) \\
  x &amp;= f(b)t+b
\end{align}\]</span> in <span class="math inline">\(b\)</span> and <span class="math inline">\(t\)</span>. To see whether this has solutions, we differentiate the both equations to both to <span class="math inline">\(x\)</span> and <span class="math inline">\(t\)</span>. This gives us <span class="math display">\[\begin{align}
  \frac{du}{dx} &amp;= \frac{df}{db}\frac{db}{dx} \\
  \frac{du}{dt} &amp;= \frac{df}{db}\frac{db}{dt} \\
  1 &amp;= (1+t\frac{df}{db})\frac{db}{dx} \\
  0 &amp;= f(b)+(1+t\frac{df}{db})\frac{db}{dt}
\end{align}\]</span> After some algebraic manipulations we get <span class="math display">\[\begin{align}
  \frac{du}{dx} &amp;= \frac{\frac{df}{db}}{1+t\frac{df}{db}} \\
  \frac{du}{dt} &amp;= \frac{-f(b)\frac{df}{db}}{1+t\frac{df}{db}}
\end{align}\]</span> Clearly, this satisfies <a class="quarto-xref" href="#eq-burger">Equation 1</a> whenever <span class="math inline">\(1+t\frac{df}{db}\neq 0\)</span>. At <span class="math inline">\(t=0\)</span>, we get the trivial statement <span class="math inline">\(1\neq 0\)</span>. This means we initially have a valid solution. Until which time that persists depends on <span class="math inline">\(f\)</span>.</p>
</section>
<section class="level3" id="time-for-shocks">
<h3 class="anchored" data-anchor-id="time-for-shocks">Time for shocks</h3>
<p>The first time at which <span class="math inline">\(1+t\frac{df}{db}=0\)</span> is called the breaking time. The time <span class="math display">\[
  t^\dagger = \inf_x\frac{-1}{f(x)}
\]</span> is the first time any characteristic breaks. This is the first time a shock appears in the solution.</p>
</section>
<section class="level3" id="simulating-some-examples">
<h3 class="anchored" data-anchor-id="simulating-some-examples">Simulating some examples</h3>
</section>
</section>
<section class="level2" id="reduction-to-heat-equation-under-viscous-conditions">
<h2 class="anchored" data-anchor-id="reduction-to-heat-equation-under-viscous-conditions">Reduction to heat equation under viscous conditions</h2>
<p>The equation that we describe now is the inviscid Burger’s equation. The viscous Burger’s equation has a viscocity term <span class="math inline">\(\nu u_xx(x,t)\)</span> with <span class="math inline">\(\nu&gt;0\)</span> such that <span id="eq-viscous-burger"><span class="math display">\[
  u_t(x,t) + u(x,t)u_x(x,t) = \nu u_xx(x,t), \quad u(0)=u_0
\tag{2}\]</span></span> With the additional term the equation becomes linearizable. When we can apply the Cole-Hopf transformation <span class="math display">\[
  u = -2\nu \frac{1}{\phi}\frac{d\phi}{dx}
\]</span> to <a class="quarto-xref" href="#eq-viscous-burger">Equation 2</a>, we get <span class="math display">\[
  \phi_{tt} = \nu \phi_{xx} + g\phi
\]</span> with <span class="math inline">\(g\)</span> a function only dependent on time that is dependent on the boundary conditions. This equation can be solved analytically. The Cole-Hopf transformation is invertable, so we can use this solution to solve the viscous Burger’s equation. This transformation breaks when <span class="math inline">\(\nu\to0\)</span>, so we cannot solve the inviscid Burger’s equation this way.</p>
</section>
<section class="level2" id="geodesic-derivation">
<h2 class="anchored" data-anchor-id="geodesic-derivation">Geodesic derivation</h2>
<p>On the circle, like we are considering, the equation can be expressed as a shortest path problem. Let us first review some geometry concepts and then apply this to Burger’s equation.</p>
<section class="level3" id="background-concepts-of-geometry">
<h3 class="anchored" data-anchor-id="background-concepts-of-geometry">Background concepts of geometry</h3>
<p>The shortest paths on manifolds are geodesics. They are the curves over the manifold that with minimal length. On manifolds, the length of a curve <span class="math inline">\(\gamma:[a,b]\to\mathcal{M}\)</span> is expressed as <span class="math display">\[
  |\gamma| := \int_a^b \sqrt{g_{\gamma(t)}(\gamma'(t), \gamma'(t))}dt.
\]</span> We can reparametrize the curve <span class="math inline">\(\gamma\)</span> without changing the length. This is not desired, so we focus instead on the energy <span class="math display">\[
  E(\gamma) = \frac{1}{2}\int_a^b g_{\gamma(t)}(\gamma'(t), \gamma'(t))dt
\]</span> where <span class="math inline">\(g\)</span> is the Riemannian metric. Minimal energy curves have minimal length, but have constant speed as well. Not having the square root makes the energy easier to work with. These curves satisfy the Euler-Arnold equation in <a class="quarto-xref" href="#eq-euler">Equation 3</a>.</p>
<div class="theorem lemma" id="lem-euler">
<p><span class="theorem-title"><strong>Lemma 1</strong></span> If <span class="math inline">\(\gamma\in C^1([a,b],\mathcal{M})\)</span> is a geodesic, then <span id="eq-euler"><span class="math display">\[
  \mu_t + B(\mu,\mu)=0
\tag{3}\]</span></span> with <span class="math inline">\(\mu=\partial_t\gamma \gamma^{-1}\)</span>, where <span class="math inline">\(B\)</span> satisfies <span class="math display">\[
  g_{e}\bigg([u,v], w\bigg) = g_{e}\bigg(v, B(u,w)\bigg)
\]</span> for <span class="math inline">\(u,v,w\in T_e\mathcal{M}\)</span>, the tangent space at the origin.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Let <span class="math inline">\(\gamma(s,t)\)</span> be a perturbation of <span class="math inline">\(\gamma(t)\)</span>. First-order optimality conditions tells us that we must have that <span class="math inline">\(\partial_s E(\gamma)_{|s=0} = 0\)</span>. At the same time, where we drop the explicit dependence on <span class="math inline">\((s,t)\)</span> for clarity, <span class="math display">\[\begin{align}
  2\partial_s E(\gamma)
    &amp;= \partial_s \int_a^b g_{\gamma}\bigg(\gamma', \gamma'\bigg)dt \\
    &amp;= \partial_s \int_a^b g_{e}\bigg(\gamma'\gamma^{-1}, \gamma'\gamma^{-1}\bigg)dt \\
    &amp;= \int_a^b \partial_s g_{e}\bigg(\gamma'\gamma^{-1}, \gamma'\gamma^{-1}\bigg)dt \\
    &amp;= \int_a^b g_{e}\bigg(\partial_s(\gamma'\gamma^{-1}), \gamma'\gamma^{-1}\bigg)dt \\
    &amp;= \int_a^b g_{e}\bigg(\partial_s(\gamma')\gamma^{-1}-\partial_s\gamma\gamma^{-1}\gamma'\gamma^{-1}, \gamma'\gamma^{-1}\bigg)dt \\
    &amp;= \int_a^b g_{e}\bigg((\partial_s\gamma\gamma^{-1})'+[\partial_s\gamma\gamma^{-1},\gamma'\gamma^{-1}], \gamma'\gamma^{-1}\bigg)dt \\
    &amp;= \int_a^b g_{e}\bigg((\partial_s\gamma\gamma^{-1})', \gamma'\gamma^{-1}\bigg)+g_{e}\bigg([\partial_s\gamma\gamma^{-1},\gamma'\gamma^{-1}], \gamma'\gamma^{-1}\bigg)dt \\
    &amp;= \int_a^b g_{e}\bigg((\partial_s\gamma\gamma^{-1})', \gamma'\gamma^{-1}\bigg)-g_{e}\bigg([\gamma'\gamma^{-1},\partial_s\gamma\gamma^{-1}], \gamma'\gamma^{-1}\bigg)dt \\
    &amp;= \int_a^b -g_{e}\bigg(\partial_s\gamma\gamma^{-1}, (\gamma'\gamma^{-1})'\bigg)-g_{e}\bigg(\partial_s\gamma\gamma^{-1}, B(\gamma'\gamma^{-1},\gamma'\gamma^{-1})\bigg)dt \\
    &amp;= \int_a^b g_{e}\bigg(\partial_s\gamma\gamma^{-1}, B(\gamma'\gamma^{-1},\gamma'\gamma^{-1})-(\gamma'\gamma^{-1})'\bigg)dt
\end{align}\]</span> Since the perturbation is arbitrary, it must be that <a class="quarto-xref" href="#eq-euler">Equation 3</a> holds.</p>
</div>
</section>
<section class="level3" id="geometry-for-burgers-equation">
<h3 class="anchored" data-anchor-id="geometry-for-burgers-equation">Geometry for Burger’s equation</h3>
<p>In this case, we consider the diffeomorphisms group <span class="math inline">\(\mathfrak{D}(S^1)\)</span> as manifold. This smooth manifold is a Lie group. That means it has a Lie Algebra, which is the Lie algebra of smooth vector fields on the circle <span class="math inline">\(\mathfrak{X}(S^1)\)</span>. Elements from this Lie algebra are written as <span class="math inline">\(f(\theta)\partial\theta\)</span> with <span class="math inline">\(f\in C^\infty(S^1)\)</span>, and the Lie bracket is <span class="math display">\[
  [f(\theta)\partial\theta, g(\theta)\partial\theta] = (f(\theta)g'(\theta)-f(\theta)g'(\theta))\partial\theta.
\]</span> We can make it a Hilbert space by assigning the inner product <span class="math display">\[
  \braket{f(\theta)\partial\theta\; |\;g(\theta)d\theta} := \int_{S^1}f(\theta)g(\theta)d\theta
\]</span> to it. The smooth dual of this space is <span class="math inline">\(\mathfrak{X}^\star(S^1)\)</span>. This has elements of the form <span class="math inline">\(u(\theta)d\theta\otimes d\theta\)</span>, and the duality bracket <span class="math display">\[
  \braket{f(\theta)\partial\theta\; |\;u(\theta)d\theta\otimes d\theta} := \int_{S^1}u(\theta)f(\theta)d\theta
\]</span> is the inner product between the coefficients of the primal and dual variables. The associated (co)adjoint actions and operators are</p>
<p><span class="math display">\[\begin{align}
  AD&amp;: \mathfrak{D}(S^1)\times \mathfrak{D}(S^1) \to \mathfrak{D}(S^1),\; &amp;&amp; AD_{\varphi}: \phi \mapsto \varphi \circ \phi \circ \varphi^{-1} \\
  Ad&amp;: \mathfrak{D}(S^1)\times \mathfrak{X}(S^1) \to \mathfrak{X}(S^1),\; &amp;&amp; Ad_{\varphi}: f(\theta) \partial_\theta \mapsto f(\varphi) \partial_\varphi\\
  Ad^\star&amp;: \mathfrak{D}(S^1)\times \mathfrak{X}(S^1)^\star \to \mathfrak{X}(S^1)^\star,\; &amp;&amp; Ad^\star_{\varphi^{-1}}: u(\theta) \, d\theta \otimes d\theta \mapsto u(\varphi) \, d\varphi \otimes d\varphi \\
  ad&amp;: \mathfrak{X}(S^1)\times \mathfrak{X}(S^1) \to \mathfrak{X}(S^1),\; &amp;&amp;ad_{f\partial\theta}: g\partial\theta \to (fg'-gf')\partial\theta \\
  ad^\star&amp;: \mathfrak{X}(S^1)\times \mathfrak{X}^\star(S^1) \to \mathfrak{X}^\star(S^1),\; &amp;&amp;ad^*_{f\partial\theta}: ud\theta\otimes d\theta \to -((fu)'+uf')d\theta\otimes d\theta.
\end{align}\]</span></p>
<p>The Lie algebra is the tangent space attached to the origin of the manifold. Hence, we can express the energy in the Lie algebra <span class="math inline">\(\mathfrak{X}(S^1)\)</span>. We do this by defining the metric as <span class="math display">\[
  g_{\gamma(t)}(\gamma'(t), \gamma'(t)) := g_{e}(\gamma'(t)\circ \gamma^{-1}(t), \gamma'(t)\circ \gamma^{-1}(t)) := \braket{\mu(t) \; | \; \mu(t)}
\]</span> with <span class="math inline">\(\mu(t)=\gamma'(t)\circ \gamma^{-1}(t)\in \mathfrak{X}(S^1)\)</span>. Since we have the braket and the metric, we can compute <span class="math inline">\(B\)</span> and thus establish our claim that Burger’s equation describes a geodesic.</p>
<div class="theorem proposition" id="prp-burgers-derivation">
<p><span class="theorem-title"><strong>Proposition 1</strong></span> Burger’s equation describes a geodesic.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>To go from <a class="quarto-xref" href="#eq-euler">Equation 3</a> to <a class="quarto-xref" href="#eq-burger">Equation 1</a> we need to show that <span id="eq-B-scaled"><span class="math display">\[
  B(\mu(t),\mu(t)) = c\mu(t)\mu'(t).
\tag{4}\]</span></span> for some <span class="math inline">\(c\neq 0\)</span>. After identifying the spatial coordinate <span class="math inline">\(x\)</span> with <span class="math inline">\(\theta\)</span> and rescaling space, we get Burger’s equation.</p>
<p>We observe that <span class="math display">\[\begin{align}
  g_{e}\bigg([u,v], w\bigg)
    &amp;= \braket{[u,v] \; | \; w } \\
    &amp;= -\braket{[v,u] \; | \; w } \\
    &amp;= -\braket{ad_vu \; | \; w } \\
    &amp;= \braket{ad^\star_v w^\flat \; | \; u } \\
    &amp;= \braket{u \; | \; (ad^\star_v w^\flat)^\sharp } \\
    &amp;= g_{e}\bigg(u, (ad^\star_v w^\flat)^\sharp \bigg)
\end{align}\]</span> for all <span class="math inline">\(u,v,w\in \mathfrak{X}(S^1)\)</span> where <span class="math display">\[\begin{align}
  ^\flat&amp;: \mathfrak{X}(S^1) \to \mathfrak{X}(S^1)^\star, \; f(\theta)\partial\theta \to f(\theta)d\theta\otimes d\theta \\
  ^\sharp&amp;: \mathfrak{X}(S^1)^\star \to \mathfrak{X}(S^1), \; u(\theta)d\theta\otimes d\theta \to u(\theta)\partial \theta
\end{align}\]</span> are the lowering and raising operators, or <span class="math inline">\(\textit{flat}\)</span> and <span class="math inline">\(\textit{sharp}\)</span>. This implies that <span class="math inline">\(B(v,w) = (ad^\star_v w^\flat)^\sharp\)</span> and thus <span class="math display">\[\begin{align}
  B(\mu,\mu)^\flat
    &amp;= ad^\star_\mu \mu^\flat \\
    &amp;= -((\mu(\theta)^2)'+\mu(\theta) \mu'(\theta))d\theta\otimes d\theta \\
    &amp;= -(2\mu(\theta)\mu(\theta)'+\mu(\theta) \mu'(\theta))d\theta\otimes d\theta \\
    &amp;= -3\mu(\theta)\mu(\theta)'d\theta\otimes d\theta.
\end{align}\]</span> Raising the index on both sides using <span class="math inline">\(^\sharp\)</span> gives us <a class="quarto-xref" href="#eq-B-scaled">Equation 4</a> with <span class="math inline">\(c=-3\)</span>.</p>
</div>
</section>
</section>
</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div>
  
</body>

</html>