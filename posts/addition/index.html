<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>

  <meta charset="utf-8">
  <meta name="generator" content="quarto-1.3.433">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


  <title></title>
  <style>
    code {
      white-space: pre-wrap;
    }

    span.smallcaps {
      font-variant: small-caps;
    }

    div.columns {
      display: flex;
      gap: min(4vw, 1.5em);
    }

    div.column {
      flex: auto;
      overflow-x: auto;
    }

    div.hanging-indent {
      margin-left: 1.5em;
      text-indent: -1.5em;
    }

    ul.task-list {
      list-style: none;
    }

    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1em;
      /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */
      vertical-align: middle;
    }

    /* CSS for syntax highlighting */
    pre>code.sourceCode {
      white-space: pre;
      position: relative;
    }

    pre>code.sourceCode>span {
      display: inline-block;
      line-height: 1.25;
    }

    pre>code.sourceCode>span:empty {
      height: 1.2em;
    }

    .sourceCode {
      overflow: visible;
    }

    code.sourceCode>span {
      color: inherit;
      text-decoration: inherit;
    }

    div.sourceCode {
      margin: 1em 0;
    }

    pre.sourceCode {
      margin: 0;
    }

    @media screen {
      div.sourceCode {
        overflow: auto;
      }
    }

    @media print {
      pre>code.sourceCode {
        white-space: pre-wrap;
      }

      pre>code.sourceCode>span {
        text-indent: -5em;
        padding-left: 5em;
      }
    }

    pre.numberSource code {
      counter-reset: source-line 0;
    }

    pre.numberSource code>span {
      position: relative;
      left: -4em;
      counter-increment: source-line;
    }

    pre.numberSource code>span>a:first-child::before {
      content: counter(source-line);
      position: relative;
      left: -1em;
      text-align: right;
      vertical-align: baseline;
      border: none;
      display: inline-block;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      padding: 0 4px;
      width: 4em;
    }

    pre.numberSource {
      margin-left: 3em;
      padding-left: 4px;
    }

    div.sourceCode {}

    @media screen {
      pre>code.sourceCode>span>a:first-child::before {
        text-decoration: underline;
      }
    }
  </style>

  
  <link type="text/css" href="/static/blog/shared.css" rel="stylesheet" />
  <link type="text/css" href="/static/blog/nav.css" rel="stylesheet" />

  <script type="text/javascript" src="/static/blog/notebooks/clipboard/clipboard.min.js"></script>
  <script type="text/javascript" src="/static/blog/notebooks/quarto-html/quarto.js"></script>
  <script type="text/javascript" src="/static/blog/notebooks/quarto-html/popper.min.js"></script>
  <script type="text/javascript" src="/static/blog/notebooks/quarto-html/tippy.umd.min.js"></script>
  <script type="text/javascript" src="/static/blog/notebooks/quarto-html/anchor.min.js"></script>

  <link href="/static/blog/notebooks/quarto-html/tippy.css" rel="stylesheet">
  <link href="/static/blog/notebooks/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
  <script type="text/javascript" src="/static/blog/notebooks/bootstrap/bootstrap.min.js"></script>
  <link href="/static/blog/notebooks/bootstrap/bootstrap-icons.css" rel="stylesheet">
  <link href="/static/blog/notebooks/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@100;200;300;400;500;600;700;800;900&amp;display=swap" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"
    integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg=="
    crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"
    integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg=="
    crossorigin="anonymous"></script>
  <script type="application/javascript">define('jquery', [], function () { return window.jQuery; })</script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <script type="text/javascript">
    window.PlotlyConfig = { MathJaxConfig: 'local' };
    if (window.MathJax && window.MathJax.Hub && window.MathJax.Hub.Config) { window.MathJax.Hub.Config({ SVG: { font: "STIX-Web" } }); }
    if (typeof require !== 'undefined') {
      require.undef("plotly");
      requirejs.config({
        paths: {
          'plotly': ['https://cdn.plot.ly/plotly-2.24.1.min']
        }
      });
      require(['plotly'], function (Plotly) {
        window._Plotly = Plotly;
      });
    }
  </script>



</head>

<body class="">
  <nav class="navbar navbar-expand-lg navbar-light bg-white py-3">
    <div class="container px-5 w-100">
        <a class="navbar-brand" href="/"><span class="fw-bolder text-title">Tjeerd Jan Heeringa</span></a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav ms-auto mb-2 mb-lg-0 small fw-bolder">
                <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
                <li class="nav-item"><a class="nav-link" href="/posts">Blog</a></li>
                <li class="nav-item"><a class="nav-link" href="/talks">Talks</a></li>
                <li class="nav-item"><a class="nav-link" href="/papers">Papers</a></li>
                <li class="nav-item"><a class="nav-link" href="/posters">Posters</a></li>
                <li class="nav-item"><a class="nav-link" href="/collaborators">Collaborators</a></li>
            </ul>
        </div>
    </div>
</nav>
  
    
<div class="page-columns page-rows-contents page-layout-article" id="quarto-content">
<main class="content" id="quarto-document-content">
<header class="quarto-title-block default" id="title-block-header">
<div class="quarto-title">
<h1 class="title">How to define: addition</h1>
</div>
<div class="quarto-title-meta">
<div>
<div class="quarto-title-meta-heading">Author</div>
<div class="quarto-title-meta-contents">
<p>T.J. Heeringa </p>
</div>
</div>
<div>
<div class="quarto-title-meta-heading">Published</div>
<div class="quarto-title-meta-contents">
<p class="date">March 23, 2025</p>
</div>
</div>
</div>
</header>
<p>In the first post of the “How to define …?” series, we introduced the sets and used them to define the natural numbers. In the second post, we introduced functions and proved the recursion theorem. We will now use what we have learned so far to define addition.</p>
<section class="level2" id="addition-using-many-times-the-successor">
<h2 class="anchored" data-anchor-id="addition-using-many-times-the-successor">Addition using many times the successor</h2>
<p>To define addition, let us look at the following figure.</p>
<div class="quarto-float quarto-figure quarto-figure-center anchored" id="fig-addition">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-addition-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img class="img-fluid figure-img" src="/static/blog/notebooks/addition/grid_addition.png"/>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-addition-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure 1: <span class="math inline">\(1+3\)</span> is the same as <span class="math inline">\(((((1+1)+1)+1)\)</span>.
</figcaption>
</figure>
</div>
<p>The figure shows instead of adding <span class="math inline">\(3\)</span> to <span class="math inline">\(1\)</span>, we can add <span class="math inline">\(1\)</span> three times to <span class="math inline">\(1\)</span>. Now, adding <span class="math inline">\(1\)</span> to a number gives the next natural number, and the successor function gives this next natural number. So, <span class="math display">\[
1+ 1 = S(1)
\]</span> and thus <span class="math display">\[
    1+3 = S(S(S(1)))
\]</span> This procedure works more generally for adding a natural number <span class="math inline">\(m\)</span> to another natural number <span class="math inline">\(n\)</span>. If we use the notation <span class="math inline">\(S^{\circ m}\)</span> for applying the successor function <span class="math inline">\(S\)</span> a total of <span class="math inline">\(m\)</span>-times so that <span class="math display">\[
\begin{align}
    S^{\circ 0}(n) &amp;= n \\
    S^{\circ 1}(n) &amp;= S(n) \\
    S^{\circ 2}(n) &amp;= S(S(n)) \\
    S^{\circ 3}(n) &amp;= S(S(S(n))) \\
    S^{\circ 4}(n) &amp;= S(S(S(S(n))))
\end{align}
\]</span> and so on, then <span class="math inline">\(n+m\)</span> can be written as <span class="math display">\[
    n+m = S^{\circ m}(n)
\]</span> The problem is that we have now defined addition in a way that requires doing something <span class="math inline">\(m\)</span>-times. We have not defined multiplication yet, so that approach does not work. In particular, we are going to define multiplication using addition. Using multiplication now would make the definition circular.</p>
</section>
<section class="level2" id="addition-using-recursion">
<h2 class="anchored" data-anchor-id="addition-using-recursion">Addition using recursion</h2>
<p>We can make it work by using the recursion theorem. By cleverly choosing the set <span class="math inline">\(X\)</span>, the element <span class="math inline">\(a\in X\)</span> and the function <span class="math inline">\(f:X\to X\)</span>, we get a function that does repeatatly apply the successor function and is guaranteed to exist.</p>
<div class="definition" id="def:m-addition">
<p><strong>Definition 1</strong>. For a fixed <span class="math inline">\(m\in\mathbb{N}\)</span>, <span class="math inline">\(+_m:\mathbb{N}\to\mathbb{N}\)</span> satisfies <span class="math inline">\(+_m(0)=0\)</span> and <span class="math inline">\(+_m(S(n)) = S(+_m(n))\)</span>.</p>
</div>
<p>The function <span class="math inline">\(+_m\)</span> can be called the “add <span class="math inline">\(m\)</span>” function, because it adds <span class="math inline">\(m\)</span> to whatever number you apply it to. Now, we just write <span class="math display">\[
     m+n = +_m(n)
\]</span> to get what we recognize as addition.</p>
</section>
<section class="level2" id="testing-the-definition">
<h2 class="anchored" data-anchor-id="testing-the-definition">Testing the definition</h2>
<p>One can wonder whether this actually works out as definition, i.e. gives the result we expect when applying it.</p>
<p>Let’s test the definition by adding <span class="math inline">\(3\)</span> to some number <span class="math inline">\(n\)</span>. Applying the definition over and over gives <span class="math display">\[
    n+3 = n+S(2) = S(n+2) = S(n+S(1)) = S(S(n+1)) = S(S(n+S(0))) =S(S(S(n+0))) = S(S(S(n)))
\]</span> which is indeed what we expect.</p>
</section>
<section class="level2" id="properties-of-addition">
<h2 class="anchored" data-anchor-id="properties-of-addition">Properties of addition</h2>
<p>To make sure that the operation we have defined addition in fact acts like addition as we would expect, we prove the following theorem.</p>
<div id="th-recursion_theorem">
<p><strong>Theorem 1</strong> Addition is associative and commutative, i.e. <span class="math display">\[
\begin{align}
    (k+m) + n &amp;= k + (m+n) \\
    m+n &amp;= n+m
\end{align}
\]</span> hold for all <span class="math inline">\(k,m,n\in \mathbb{N}\)</span>.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Both properties are proven using induction on <span class="math inline">\(n\)</span>.</p>
<p>Let <span class="math inline">\(k,m\in\mathbb{N}\)</span>. If <span class="math inline">\(n=0\)</span>, then <span class="math display">\[
    (k+m) + 0 = k+m = k+(m+0)
\]</span> This shows the base case. If associativity holds at <span class="math inline">\(n\in\mathbb{N}\)</span>, then <span class="math display">\[
    (k+m)+S(n) = S((k+m)+n) = S(k+(m+n)) = k+S(m+n)) = k+(m+S(n))
\]</span> This shows that associativity also holds for <span class="math inline">\(S(n)\)</span>, completing the inductive step. Since <span class="math inline">\(k,m\)</span> were arbitrary and associativity holds for all <span class="math inline">\(n\in\mathbb{N}\)</span>, associativity holds for all <span class="math inline">\(k,m,n\in\mathbb{N}\)</span>.</p>
<p>To show commutativity, we want to use <span class="math inline">\(0+n=n\)</span> and <span class="math inline">\(S(m)+n=S(m+n)\)</span>. This is not given, so we prove them first. This will again be by induction.</p>
<p>For the former, observe that <span class="math display">\[
    0 + n = n
\]</span> for all <span class="math inline">\(n\in\mathbb{N}\)</span>. This shows the base case. If <span class="math inline">\(0+n=n\)</span> holds for <span class="math inline">\(n\)</span>, then <span class="math display">\[
    0+S(n) = S(0+n) = S(n)
\]</span> This shows that the property also holds for <span class="math inline">\(S(n)\)</span>, completing the inductive step.</p>
<p>For the latter, let <span class="math inline">\(m\in\mathbb{N}\)</span>. If <span class="math inline">\(n=0\)</span>, then <span class="math display">\[
    S(m+0) = S(m) = S(m+0)
\]</span> If <span class="math inline">\(S(m)+n = S(m+n)\)</span> holds for <span class="math inline">\(n\)</span>, then <span class="math display">\[
    S(m)+S(n) = S(S(m)+n) = S(S(m+n)) = S(m+S(n))
\]</span> This shows that the property also holds for <span class="math inline">\(S(n)\)</span>, completing the inductive step.</p>
<p>Now, we have the tools needed to show commutativity. Again, fix <span class="math inline">\(m\in\mathbb{N}\)</span>. For the base case, observe that <span class="math display">\[
    0 + m = m = m + 0
\]</span> For the induction step, assume that the <span class="math inline">\(n+m=m+n\)</span>. This implies that <span class="math display">\[
    S(n)+m = S(n+m) = S(m+n) = m+S(n)
\]</span> Hence, the property holds for <span class="math inline">\(S(n)\)</span> too, completing the inductive step.</p>
</div>
</section>
<section class="level2" id="wrap-up">
<h2 class="anchored" data-anchor-id="wrap-up">Wrap-up</h2>
<p>So, we have now seen how the recursion theorem can be used to define the “add <span class="math inline">\(m\)</span>” function <span class="math inline">\(+_m\)</span>, and we have seen that this function has all the properties of addition. This wraps up our discussion about addition on the natural numbers. In the next post, we move on to multiplication and exponentiation.</p>
</section>
</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div>
  
</body>

</html>